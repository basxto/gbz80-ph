; must be all in one file
; more info https://sourceforge.net/p/sdcc/code/HEAD/tree/trunk/sdcc/src/SDCCpeeph.c

replace {
 ; redundant AND
 and	a, #0x10
 swap	a
 and	a, #0x0f
} by {
 and	a, #0x10;2b 2c saved
 swap	a
}

replace {
 ; redundant AND
 and	a, #0x0f
 and	a, #0x01
} by {
 and	a, #0x01;2b 2c saved
}



replace {
 ; ld	a, (hl+/-) is faster
 ld	%2, (hl)
 inc	hl
 ld	%1, (hl)
 dec	%1%2
 dec	hl
} by {
 ld	a, (hl+);1b 2c
 ld	%2, a	;1b 1c
 ld	a, (hl-);1b 2c
 ld	%1, a	;1b 1c
 dec	%1%2	;1b 2c
} if canAssign(%2 'a'), canAssign(%1 'a'), notUsed('a')

replace {
 ; ld	a, (hl+/-) is faster
 ld	a, (hl)
 dec	hl
} by {
 ld	a, (hl-);save 1b 2c
}

replace {
 ld	%1, (hl)
 dec	hl
} by {
 ld	a, (hl-);1b 2c
 ld	%1, a	;1b 1c
} if canAssign(%1 'a'), notUsed('a')

replace {
 ld	a, (hl)
 inc	hl
} by {
 ld	a, (hl+);save 1b 2c
}

replace {
 ld	%1, (hl)
 inc	hl
} by {
 ld	a, (hl+);1b 2c
 ld	%1, a	;1b 1c
} if canAssign(%1 'a'), notUsed('a')

replace {
 ; ld	a, (hl+/-) is faster
 ld	(hl), a
 dec	hl
} by {
 ld	(hl-), a;save 1b 2c
}

replace {
 ld	(hl), %1
 dec	hl
} by {
 ld	a, %1	;1b 1c
 ld	(hl-), a;1b 2c
} if canAssign('a' %1), notUsed('a')

replace {
 ld	(hl), a
 inc	hl
} by {
 ld	(hl+), a;save 1b 2c
}

replace {
 ld	(hl), %1
 inc	hl
} by {
 ld	a, %1	;1b 1c
 ld	(hl+), a;1b 2c
} if canAssign('a' %1), notUsed('a')




replace {
 ; 16bit <<4
 ld	  %1, (hl)
 ld	  %2, #0x00
 sla  %1
 rl   %2
 sla  %1
 rl   %2
 sla  %1
 rl   %2
 sla  %1
 rl   %2
} by {
 ld   a, (hl)	; no backup needed
 swap a
 ld   %1, a
 and  a, #0x0f
 ld   %2, a
 ld   a, %1
 and  a, #0xf0
 ld   %1, a
} if canAssign(%2 'a'), canAssign(%1 'a'), canAssign('a' %1), notUsed('a')

replace {
 ; 16bit <<4
 ld	  %1, (hl)
 ld	  %2, #0x00
 sla  %1
 rl   %2
 sla  %1
 rl   %2
 sla  %1
 rl   %2
 sla  %1
 rl   %2
} by {
 push af ; backup
 ld   a, (hl)
 swap a
 ld   %1, a
 and  a, #0x0f
 ld   %2, a
 ld   a, %1
 and  a, #0xf0
 ld   %1, a
 pop  af ; restore
} if canAssign(%2 'a'), canAssign(%1 'a'), canAssign('a' %1)


replace {
 xor	a, a
 push	af
 inc	sp
 xor	a, a
 push	af
 inc	sp
 xor	a, a
 push	af
 inc	sp
} by {
 ; three 0 arguments
 xor	a, a
 push	af
 inc	sp
 xor	a, a
 push	af
 inc	sp
 push	af
 inc	sp
}

replace {
 xor	a, a
 push	af
 inc	sp
 xor	a, a
 push	af
 inc	sp
} by {
 ; even faster than ld bc, #0
 xor	a, a	; 1b 1c ; a=0
 rra		; 1b 1c ; f=0
 push	af	; 3b 8c saved
}

replace {
 xor	a, a
 push	af
 inc	sp
 ld	a, #0x80
 push	af
 inc	sp
} by {
 ; no idea if somebody needs this
 xor	a, a	; 1b 1c ; a=0 f=0x80
 push	af	; 5b 9c saved
}


replace {
 ld	%1, #%3
 push	%1%2
 inc	sp
 ld	%1, #%3
 push	%1%2
 inc	sp
} by {
 ld	%1, #%3 ; need this just once
 push	%1%2
 inc	sp
 push	%1%2
 inc	sp
}

replace {
 ld	%1, #%3
 push	%1%2
 inc	sp
 push	%1%2
 inc	sp
 ld	%1, #%3
 push	%1%2
 inc	sp
} by {
 ld	%1, #%3 ; need this just once
 push	%1%2
 inc	sp
 push	%1%2
 inc	sp
 push	%1%2
 inc	sp
}

replace {
 ld	a, #%1
 push	af
 inc	sp
 ld	a, #%2
 push	af
 inc	sp
} by {
 ld	a, #%1
 push	af
 inc	sp
 inc	a ; previous paramater
 push	af
 inc	sp
} if immdInRange(1 1 'sub' %2 %1 %3)

replace {
 ld	a, #%1
 push	af
 inc	sp
 ld	a, #%2
 push	af
 inc	sp
} by {
 ld	a, #%1
 push	af
 inc	sp
 dec	a ; previous paramater
 push	af
 inc	sp
} if immdInRange(1 1 'sub' %1 %2 %3)